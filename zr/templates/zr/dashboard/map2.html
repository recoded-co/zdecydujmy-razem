{% load i18n %}
{% load isloged %}
{% load url from future %}
<script src="http://maps.google.com/maps/api/js?sensor=false"></script>
<style type="text/css">

    .smallmap {
        width: 100%;
        height: 480px;
        border: 1px solid #ccc;
    }
    .olControlPanel div {
      position: absolute;
      left: 12px;
      top: 22px;
      display:block;
      width:  18px;
      height: 18px;
      margin: 5px;
      background-image: url("/static/img/zoom-world-mini.png");
    }

    .marker-cluster-small-pol {
        background-color: rgba(0, 0, 226, 0.6);
        }
    .marker-cluster-small-pol div {
        background-color: rgba(0, 0, 204, 0.6);
        }

    .marker-cluster-medium-pol {
        background-color: rgba(0, 0, 211, 0.6);
        }
    .marker-cluster-medium-pol div {
        background-color: rgba(0, 0, 194, 0.6);
        }

    .marker-cluster-large-pol {
        background-color: rgba(0, 0, 156, 0.6);
        }
    .marker-cluster-large-pol div {
        background-color: rgba(0, 0, 128, 0.6);
        }
</style>

<script type="text/javascript">
    var lon = parseFloat("{{ plan.center.x|escapejs }}");
    var lat = parseFloat("{{ plan.center.y|escapejs }}");
    var scope = "{{ plan.geocoding_scope }}";
    var zoom = parseInt("{{ plan.zoom_level }}")
    var after_search_zoom = parseInt("{{ plan.after_search_zoom }}");
    var map, drawControls, selectedFeature,wtk,vectors,layerWaitingRoom;
    var plan_id = parseInt('{{ plan_id }}');
    var user = '{{ user }}';
    var search_filter_layer = undefined;



    function geolocate(address){

    	var geocoder = new google.maps.Geocoder();
		if (geocoder) {
			geocoder.geocode({ 'address': address, 'region':'pl' }, function (results, status) {
				if (status == google.maps.GeocoderStatus.OK) {
					var geometry = results[0].geometry.location;
                    map.setView([geometry.lat(), geometry.lng()], after_search_zoom);
         		} else {
            		console.log("Geocoding failed: " + status);
         		}
      		});
   		}
    }

    $( "#map-search-button").click(function(){
        var address = $( "#map-search-input").val();
        geolocate(address);
    })
    $( "#map-search-input").val(scope+', ');

    function map_init(){


        var osm =
            L.tileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: 'Map data © OpenStreetMap contributors',
                maxZoom: 19,
                minZoom: 0,
                legend: LEGEND
            });

        var lmap =
            L.tileLayer('http://{s}.tile.cloudmade.com/133079e21d8949fb8df55013e541c5d9/997/256/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
                maxZoom: 18,
                legend: LEGEND
            });

        var mbmap =
            L.tileLayer('http://{s}.tiles.mapbox.com/v3/mmlodkowski.gpl722i4/{z}/{x}/{y}.png', {
                attribution: "<a href='http://mapbox.com/about/maps' target='_blank'>Terms & Feedback</a>",
                maxZoom: 18,
                legend: LEGEND,
                openLegendOnLoad: true
            });

    /*
    var mbmap =
            L.tileLayer('http://www.poznan.pl/tilecache/tilecache.cgi/1.0.0/poznan_studium/1/{z}/{x}/{y}.png', {
                attribution: "<a href='http://mapbox.com/about/maps' target='_blank'>Terms & Feedback</a>",
                maxZoom: 18,
                legend: LEGEND,
                openLegendOnLoad: true
            });
    */
  /*
        var mbmap = L.tileLayer.wms("http://www.poznan.pl/tilecache/tilecache.cgi?", {
            layers: ['poznan_studium'],
            format: 'image/png',
            attribution: "Weather data © 2012 IEM Nexrad"
        });
*/




        var baseMaps = {
           // "Open Street Map": osm,
            "Mapa": lmap,
            "Zdjęcia satelitarne": mbmap
        };
        var mpzp =
                L.tileLayer('http://{s}.tile.cloudmade.com/133079e21d8949fb8df55013e541c5d9/997/256/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
                        maxZoom: 18
                });
                var studium = L.tileLayer('http://{s}.tile.cloudmade.com/133079e21d8949fb8df55013e541c5d9/997/256/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
                        maxZoom: 18
                });
                var strukturaWlasnosci = L.tileLayer('http://{s}.tile.cloudmade.com/133079e21d8949fb8df55013e541c5d9/997/256/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
                        maxZoom: 18
                });
                var wynikiAnkiet = L.tileLayer('http://{s}.tile.cloudmade.com/133079e21d8949fb8df55013e541c5d9/997/256/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://cloudmade.com">CloudMade</a>',
                        maxZoom: 18
                });


        var basePlanLayer = L.geoJson([], {
           style: planMapStyle,
           onEachFeature: function (feature, layer) {
               var pcontent = '';
               feature.properties.feat_description.forEach(function(o){
                   if (o.value !== ''){
                    pcontent += "<h5>"+ o.key+"</h5><p>"+o.value+"</p>";
                   }
               });
               var popup = L.popup({
                   "maxHeight": 200
               });
               popup.setContent(pcontent);
               layer.bindPopup(popup);
           }
        });


        var overlayMaps = {
        "MPZP": basePlanLayer,
                "Studium": studium,
                "Struktura własności": strukturaWlasnosci,
                "Wyniki ankiet": wynikiAnkiet
        };

        map = L.map('map', {
            attributionControl: false,
            editInOSMControl: true,
            editInOSMControlOptions: {position: 'topleft'},
            center: new L.LatLng(lat, lon),
            zoom: zoom,
            measureControl: true,
            measurePolygonControl: true,
            layers: [mbmap],
            minZoom: 1,
            maxZoom: 17
        });

        map.addLayer(basePlanLayer); // city plan base layer


        var planMapStyle = {
            "color": "#e74c3c",
            "weight": 5,
            "opacity": 0.65
        }

    $.getJSON("{% url 'subjects_geojson' plan.id  %}", function (data) {
            basePlanLayer.addData(data);
            basePlanLayer.bringToBack();
        });


        var additionalLayers = {
            //"Propozycja planu": basePlanLayer
        }
        //L.control.layers(baseMaps, additionalLayers, {'collapsed':false}).addTo(map);

        L.control.layers(baseMaps, overlayMaps, {'collapsed':false}).addTo(map);
        var drawnItems = new L.FeatureGroup();
        layerWaitingRoom = new Array();
        map.addLayer(drawnItems);

        var searchItems = new L.FeatureGroup();
        search_filter_layer = searchItems;
        map.addLayer(searchItems);

        L.control.scale().addTo(map);

        var legendControl = (new L.Control.TileLegend()).addTo(map);

        //remote control switch functions
        map.remoteControlSwitchOff = function(){
            if(map.remoteControlSwitch!=undefined && map.remoteControlContent!=undefined){
                map.remoteControlSwitch.call(map.remoteControlContent);
                map.remoteControlSwitch = undefined;
                map.remoteControlContent = undefined;
            }
        }
        map.setRemoteControlSwitch = function (content,method){
            map.remoteControlSwitch = method;
            map.remoteControlContent = content;
        }
        map.clearControlSwitch = function (){
            map.remoteControlSwitch = undefined;
            map.remoteControlContent = undefined;
        }
        map.invalidateSize();

        $(document).ready(function(){
            var resizeStart = false;
            $('#resizible_jquery').resize(function(e){
                if(!resizeStart){
                    resizeStart=true;
                }
            });
            $(document).mouseup(function(){
                if(resizeStart){
                    map.invalidateSize();
                    resizeStart=false;
                }
            });
            map.on('popupopen', function(e) {
              var marker = e.popup._source;
              $('#map-search').toggle('slow');
              $('.leaflet-control-layers.leaflet-control-layers-expanded.leaflet-control').toggle('slow');
              $('#popPublish').click(function(){
                    map.addLayer(layerWaitingRoom.pop());
                    alert('publish on!');
              });
            });
            map.on('popupclose', function(e) {
              var marker = e.popup._source;
              $('#map-search').toggle('slow');
              $('.leaflet-control-layers.leaflet-control-layers-expanded.leaflet-control').toggle('slow');
              if(layerWaitingRoom){
                while(layerWaitingRoom.length > 0){
                    map.removeLayer(layerWaitingRoom.pop());
                    }
              }
            });
        });

{% if user|isloged %}
// edit teodor @ katalpa
        var drawControl = new L.Control.Draw({
			position: 'topright',
			draw: {
                polygon: {
					allowIntersection: false,
					showArea: true,
					drawError: {
						color: '#b00b00',
						timeout: 1000,
                        message: '<strong>Błąd<strong>'
					},
					shapeOptions: {
						color: '#0033ff'//'#bfadf55',
					}
                },
                polyline: {
					allowIntersection: false,
					showArea: true,
					drawError: {
						color: '#b00b00',
						timeout: 1000,
                        message: '<strong>Błąd<strong>'
					},
					shapeOptions: {
						color: '#0033ff'//'#bfadf55',
					}
                },
                rectangle: true,
                circle: false
			},
			edit: {
				featureGroup: drawnItems,
				remove: false,
                edit: false
			}
		});
		map.addControl(drawControl);


  //       var search = new L.Control.Draw({
		// 	position: 'topright',
		// 	draw: {
		// 		polyline: true,
		// 		circle: false,
  //               rectangle: true,
  //               marker: false,
  //               polygon: false
  //           }
		// });
		//map.addControl(search); // edit teodor @ katalpa

{% endif %}
		map.on('draw:created', function (e) {
			var type = e.layerType,
                    layer = e.layer;

            var wkt = new Wkt.Wkt();
            if (type === 'rectangle'){ // search
                var wkt_bb = wkt.fromObject(L.polygon(e.layer._latlngs));
                var wkt_string = wkt.write();

                searchItems.addLayer(layer);
                layer.on('click', function(e){
                    trackEvent('search rectangle','clicked',user,'','');
                    searchItems.removeLayer(layer);
                    addPostFilter(undefined);
                });

                geoSearch(wkt_string, plan_id, function(data, textStatus, jqXHR) {
                    // TODO search results callback
                    if(data.length>0){
                        addPostFilter(data);
                    }else{
                        addPostFilter([{id:-1}]);
                    }
                });

            }else{
                var popup_location = null;

                if (type === 'marker') {
                    trackEvent('marker create','clicked',user,'','');
                    layer.bindPopup(popup);
                    popup_location = e.layer._latlng;
                    var point = L.marker(e.layer._latlng);
                    wkt.fromObject(point);

                } else if (type === 'polygon'){
                    trackEvent('polygon create','clicked',user,'','');
                    popup_location = e.layer._latlngs[0];
                    wkt.fromObject(L.polygon(e.layer._latlngs));

                } else if (type === 'polyline'){
                    trackEvent('polyline create','clicked',user,'','');
                    popup_location = e.layer._latlngs[0];
                    wkt.fromObject(L.polyline(e.layer._latlngs));
                }


                //console.log(wkt.components);
                var wkt_string = wkt.write();
                //console.log(wkt_string);

                var popup = L.popup()
                    .setLatLng(popup_location)
                    .setContent("<div>" +
                                             "<div class='map_popup'> " +
                                             "<textarea placeholder='Komentarz' id='popup_comment' rows='3'>" +
                                             "</textarea ><br>" +
                                             "<input id='geometry' type='hidden' value='"+wkt_string+"'/>" +
                                             "<input id='feature_id' type='hidden' value='"+"'/>" +
                                             "</div> " +
                                             "<hr>" +
                                             "<button id='popPublish' class='btnred btn btn-xs' onclick='addPopup(this);return false;' >publikuj</button>" +
                                             "</div>");
                map.openPopup(popup);
                layerWaitingRoom.push(layer);
                drawnItems.addLayer(layer);
            }

		}).on('draw:drawstart',function(e){
            var type = e.layerType;
            map.remoteControlSwitchOff();

            if (type === 'rectangle'){
                L.DomUtil.addClass(e.target._container, 'leaflet-control-rectangle-on');
            } else if(type === 'marker') {
                L.DomUtil.addClass(e.target._container, 'leaflet-control-marker-on');
            } else if(type==='polygon'){
                L.DomUtil.addClass(e.target._container, 'leaflet-control-polygon-on');
            } else if(type==='polyline'){
                L.DomUtil.addClass(e.target._container, 'leaflet-control-polyline-on');
            }
        }).on('draw:drawstop',function(e){
            var type = e.layerType;

            if (type === 'rectangle'){
                L.DomUtil.removeClass(e.target._container, 'leaflet-control-rectangle-on');
            } else if(type === 'marker') {
                L.DomUtil.removeClass(e.target._container, 'leaflet-control-marker-on');
            } else if(type==='polygon'){
                L.DomUtil.removeClass(e.target._container, 'leaflet-control-polygon-on');
            } else if(type==='polyline'){
                L.DomUtil.removeClass(e.target._container, 'leaflet-control-polyline-on');
            }
        });

        addGeometry(function(markers){
            //vectors.events.register('featureadded','',featureAddedFunction);
            /*
            for (k in markers){
                additionalLayers[k]=markers[k];
                additionalLayers[k].bringToFront();
            }*/
        });

    }


    function setVectorStyle(name,color){
        return new OpenLayers.StyleMap({
				        "default": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: .7,
				            strokeWidth: 1,
				            fillColor: color,
				            fillOpacity: .5,
				            cursor: "pointer"
				        }),
				        "temporary": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: 1,
				            strokeWidth: 2,
				            fillColor: color,
				            fillOpacity: .9,
				            cursor: "pointer",
				            label: ""+name// "${"+MapLayerList[x]['name_param']+"}"
				        }),
				        "select": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: .9,
				            strokeWidth: 2,
				            fillColor: color,
				            fillOpacity: .9,
				            graphicZIndex: 2,
				            cursor: "pointer"
				        })
        });
    }

    /**
     * TODO add polygon method
     * @param callback
     */
    function addGeometry(callback){
        // TODO !!!! pass plan id here, right now you get all data from all plans in the system
        $.getJSON( "/zr/api/geometries/?format=json", function( data ) {
            var count = data.length;
            addMarkers(data, function(layers){
                callback(layers);
            });
            /*
            $.each(data,function(key,value){
                parseWKT(value.geoelement,value.name);
                if(!--count){
                    callback();
                }
            })
            */
        });
    }

    function _getCentroid(points){
        var i, j, len, p1, p2, f, area, x, y,
        // polygon centroid algorithm; only uses the first ring if there are multiple
        area = x = y = 0;
        for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            p1 = points[i];
            p2 = points[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x += (p1.x + p2.x) * f;
            y += (p1.y + p2.y) * f;
            area += f * 3;
        }
        return [x / area, y / area];
    }

    function addMarkers(data, callback){

        var count = data.length;
        var markers = L.markerClusterGroup({showCoverageOnHover: false,
                                            zoomToBoundsOnClick: true,
                                            spiderfyOnMaxZoom: true,
                                            removeOutsideVisibleBounds: true});
        var lines = L.markerClusterGroup({showCoverageOnHover: false,
                                            zoomToBoundsOnClick: true,
                                            spiderfyOnMaxZoom: true,
                                            removeOutsideVisibleBounds: true});
        var polygon_markers = L.markerClusterGroup({
                                            showCoverageOnHover: true,
                                            zoomToBoundsOnClick: true,
                                            spiderfyOnMaxZoom: true,
                                            removeOutsideVisibleBounds: true,

                                            iconCreateFunction: function(cluster) {
                                                var childCount = cluster.getChildCount();
                                                var c = ' marker-cluster-';
                                                if (childCount < 10) {
                                                    c += 'small';
                                                } else if (childCount < 100) {
                                                    c += 'medium';
                                                } else {
                                                    c += 'large';
                                                }
                                                  return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster ' + c + '-pol', iconSize: new L.Point(40, 49) });

                                                // return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster ' + c + '-pol', iconSize: new L.Point(40, 40) });
                                            }
                                });


        map.on("click",function(e){
            trackEvent('map area','clicked',user,'','');
            addPostFilter(undefined);
        });

		$.each(data,function(key, value){
			var wkt = new Wkt.Wkt();
            //console.log(value);
            wkt.read(value.geoelement);
            var components = wkt.components[0];

            //console.log('components');
            //console.log(components);

            if (Array.isArray(components)){
                var latlngs = new Array();
                for (var i in components){
                    var xy = components[i];
                    latlngs.push(L.latLng(xy.y, xy.x));
                }
                var polygon = L.polygon(latlngs);
                var centroid = _getCentroid(components);
                var xy = centroid; //components[0];
                var latlng = L.latLng(xy[1], xy[0]);
                var baloonMarker = L.icon({
                     iconUrl: '/static/images/balonik_1.png',
                     iconSize:     [30, 26], // size of the icon
                     iconAnchor:   [0, 26], // point of the icon which will correspond to marker's location
                     popupAnchor:  [-3, -26] // point from which the popup should open relative to the
                    })

                var marker = L.marker(latlng, {icon: baloonMarker});

                marker.on('mouseover', function(){
                    polygon.addTo(map);
                    //postLightOn(value.id); // scrolls comments to current point

                    polygon.on('mouseout', function(e){
                       //postLightOff(value.id); // revers scroll after mouseover
                       map.removeLayer(polygon);
                    });
                });

                marker.on("click", function(e){
                    trackEvent('marker','marker clicked','','','');
                    addPostFilter([{id:value.geo_id}]);
                });
                polygon.on('click', function(e){
                       trackEvent('polygon','clicked',user,'','');
                       addPostFilter([{id:value.geo_id}]);
                });

                polygon_markers.addLayer(marker);
            } else{

                type = value.geoelement.match(/[A-Z]+/);

                if(type == 'POINT'){
                    var xy = components;
                    var latlng = L.latLng(xy.y, xy.x);
                    var marker = L.marker(latlng, {});
                    marker.on('mouseover', function(){

                        marker.on('mouseout', function(){
                           //postLightOff(value.id);
                           map.removeLayer(polygon);
                        });
                    });
                    marker.on('click', function(e){
                           //postLightOn(value.id);
                           //trackEvent('point','clicked',user,'','');
                           addPostFilter([{id:value.geo_id}]);
                    });
                    markers.addLayer(marker);

                } else if( type == 'LINESTRING' ){
                    var point_list = new Array();
                    var temporaryPoint = {};
                    var tempStr = value.geoelement.split(' ');
                    var finallyList = new Array();
                    var finallyListOb = new Array();

                    for(var item in tempStr ){
                        if(tempStr[item].match(/\d+[.]+\d+/)){
                            point_list.push(tempStr[item].match(/\d+[.]+\d+/));
                        }
                    }

                    for(var item=0; item<point_list.length; item++){
                        var x = point_list[item++][0];
                        var y = point_list[item][0];
                        finallyListOb.push({x:parseFloat(x),y:parseFloat(y)});
                        finallyList.push(L.latLng(parseFloat(y), parseFloat(x)));
                    }

                    var polyline = L.polyline(finallyList);
                    var latlng = L.latLng(finallyListOb[0].y, finallyListOb[0].x);
                    var baloonMarker = L.icon({
                         iconUrl: '/static/images/balonik_1.png',
                         iconSize:     [30, 26], // size of the icon
                         iconAnchor:   [0, 26], // point of the icon which will correspond to marker's location
                         popupAnchor:  [-3, -26] // point from which the popup should open relative to the
                        });

                    var marker = L.marker(latlng, {icon: baloonMarker});

                    marker.on('mouseover', function(){
                        polyline.addTo(map);
                    });
                    marker.on('mouseout', function(){
                        map.removeLayer(polyline);
                    });

                    marker.on("click", function(e){
                        trackEvent('marker','marker clicked','','','');
                        addPostFilter([{id:value.geo_id}]);
                    });
                    polyline.on('click', function(e){
                           trackEvent('polyline','clicked',user,'','');
                           addPostFilter([{id:value.geo_id}]);
                    });
                    lines.addLayer(marker);
                }
            }
            if(!--count){
                map.addLayer(markers);
                map.addLayer(polygon_markers);
                map.addLayer(lines);
                if (callback != undefined){
                    callback();
                }
            }
		});
        callback({'punkty':markers, 'poligony':polygon_markers, 'lines':lines});
    }

    function clearGeoSearchFilter(){
        trackEvent('search rectangle','clicked',user,'','');
        if (search_filter_layer){
            search_filter_layer.clearLayers();
        }
        addPostFilter(undefined);
    };

    function postLightOn(id){
        var LightOn = $("#div_apiList").scope().postLightOn;
        LightOn(id);
        $("#div_apiList").scope().$apply();
        if($('#'+id).position())
            $("#resizible_jquery").animate({scrollTop: $('#resizible_jquery').scrollTop()+$('#'+id).position().top}, "slow");
    };

    function postLightOff(id){
        var LightOff = $("#div_apiList").scope().postLightOff;
        LightOff(id);
        $("#div_apiList").scope().$apply();
    };

    function parseWKT(value, name) {
        var wkt = new Wkt.Wkt();
        wkt.read(value);
        var components = wkt.components[0];

        if (Array.isArray(components)){
            var latlngs = new Array();
            for (var i in components){
                var xy = components[i];
                var latlng = L.latLng(xy.y, xy.x);
                latlngs.push(L.latLng(xy.y, xy.x));
            }
            var polygon = L.polygon(latlngs);
            polygon.addTo(map);
        } else{
            var xy = components;
            var latlng = L.latLng(xy.y, xy.x);
            var marker = L.marker(latlng, {});
            marker.addTo(map);
        }
    }

    function toggleControl(element) {
        var map = {'Dodaj punkt':'point','Dodaj poligon':'polygon'};
        var control = drawControls[map[element.value]];
        control.activate();
    }
    function stripObj(obj){
        window.stripObj = obj;
    }
    function displayWKT(feature) {
        var str = wkt.write(feature);
        return str;
    }
    function addPopup(data){
        // get data from popup and send it to server
        var temp = {}
        var temp_geometry = $(data).parent().find('#geometry').val();
        if (temp_geometry.indexOf('POLYGON')!=-1){
            temp['poly']=temp_geometry;
        } else if (temp_geometry.indexOf('POINT')!=-1){
            temp['point']=temp_geometry;
        } else if (temp_geometry.indexOf('LINESTRING')!=-1){
            temp['line']=temp_geometry;
        } else {
            alert('Error: no poly or point data detected!!');
        }
        temp['name']='noname';

        var comment = $(data).parent().find('#popup_comment').val();
        if(comment){
            $.ajax({
                url : "/zr/api/geometries/",
                type: "POST",
                data : temp,
                headers: {'X-CSRFToken': $.cookie('csrftoken')},
                success: function(data, textStatus, jqXHR)
                {
                    trackEvent('post added','clicked',user,'','');
                    addComentToGeoElement(data,comment);
                },
                error: function (jqXHR, textStatus, errorThrown)
                {
                    console.log('error: ' + textStatus);
                }
            });
            map.closePopup();
            layerWaitingRoom = new Array();
        } else {
            alert('comment needed!');
        }
    }

    function addComentToGeoElement(data, comment){
        var pushCommentIntoScope = $("#div_apiList").scope().pushCommentIntoScope;
        pushCommentIntoScope(data, comment);
        $("#div_apiList").scope().$apply();
    }

    function trackEvent(category, action, opt_label, opt_value, opt_noninteraction){
        var track = $("#div_apiList").scope().trackEvent;
        track(category, action, opt_label, opt_value, opt_noninteraction);
        $("#div_apiList").scope().$apply();
    }

    function addPostFilter(data){
        var addPFilter = $("#div_apiList").scope().addPFilter;
        addPFilter(data);
        $("#div_apiList").scope().$apply();
        $("#nav-tabs-menu").find('li:eq(0)').removeClass('active');
        $("#nav-tabs-menu").find('li:eq(1)').removeClass('active');
        $("#nav-tabs-menu").find('li:eq(2)').removeClass('active');
        $("#nav-tabs-menu").find('li:eq(0)').addClass('active');
    }
    function deletePopoup(data){
        // get data from popup and send it to server
        var feature_id = $(data).parent().find('#feature_id').val();
        vectors.eraseFeatures([vectors.getFeatureById(feature_id)]);
        map.popups[0].destroy();
    }

    function geoSearch(wkt, plan_id, success_callback){

        if(wkt){
            $.ajax({
                url : '/zr/api/geosearch/'+plan_id+'/',
                type: 'POST',
                data : 'wkt='+wkt,
                headers: {'X-CSRFToken': $.cookie('csrftoken')},
                success: success_callback,
                error: function (jqXHR, textStatus, errorThrown)
                {
                    console.log('error: ' + textStatus);
                }
            });
        } else {
            alert('Search are needed!');
        }
    }
</script>

<div id="map" class="smallmap"></div>
