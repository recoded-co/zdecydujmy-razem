{% load i18n %}
{% load isloged %}


<script src="http://openlayers.org/dev/OpenLayers.js"></script>
<script src="http://maps.google.com/maps/api/js?sensor=false"></script>
<style type="text/css">
    .smallmap {
        width: 100%;
        height: 480px;
        border: 1px solid #ccc;
    }
    .olControlPanel div {
      position: absolute;
      left: 12px;
      top: 22px;
      display:block;
      width:  18px;
      height: 18px;
      margin: 5px;
      background-image: url("/static/img/zoom-world-mini.png");
    }
</style>
<script type="text/javascript">
    var lon = 16.9666667;
    var lat = 52.4166667;
    var zoom = 12;
    var map, drawControls, selectedFeature,wtk,vectors;
    var plan_id = parseInt('{{ plan_id }}');

    function geolocate(address){

    	var geocoder = new google.maps.Geocoder();
		if (geocoder) {
			geocoder.geocode({ 'address': address+'{{ scope }}', 'region':'pl' }, function (results, status) {
				if (status == google.maps.GeocoderStatus.OK) {
					var geometry = results[0].geometry.location;
                    /*
                    var foundPosition = new OpenLayers.LonLat(geometry.lng(), geometry.lat()).transform(
							new OpenLayers.Projection("EPSG:4326"),
                    		map.getProjectionObject()
                    );
                    var zoom = map.getZoom();
                    zoom = 14;
            		map.setCenter(foundPosition, zoom);
                    */
                    map.setView([geometry.lat(), geometry.lng()], zoom);
         		} else {
            		console.log("Geocoding failed: " + status);
         		}
      		});
   		}
    }

    function map_init(){

        var osm =
            L.tileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: 'Map data Â© OpenStreetMap contributors',
                maxZoom: 19,
                minZoom: 0
            });
        //var googleLayer = new L.Google('SATELLITE');


        map = L.map('map', {
            center: new L.LatLng(lat, lon),
            zoom: zoom,
            layers: [osm]
        });

        L.control.layers(osm, null).addTo(map);

        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        var searchItems = new L.FeatureGroup();
        map.addLayer(searchItems);

        L.control.scale().addTo(map);

{% if user|isloged %}

        var drawControl = new L.Control.Draw({
			position: 'topright',
			draw: {
				polyline: false,
				circle: false,
                rectangle: false,

                polygon: {
					allowIntersection: true,
					showArea: true,
					drawError: {
						color: '#b00b00',
						timeout: 1000
					},
					shapeOptions: {
						color: '#bfadf55',
                        dupa: 1
					}
				}
			},
			edit: {
				featureGroup: drawnItems,
				remove: false,
                edit: false
			}
		});
		map.addControl(drawControl);


        var search = new L.Control.Draw({
			position: 'topright',
			draw: {
				polyline: false,
				circle: false,
                rectangle: true,
                marker: false,
                polygon: false
            }
		});
		map.addControl(search);

{% endif %}
		map.on('draw:created', function (e) {
			var type = e.layerType,
				layer = e.layer;

            var wkt = new Wkt.Wkt();
            if (type === 'rectangle'){ // search
                var wkt_bb = wkt.fromObject(L.polygon(e.layer._latlngs));
                var wkt_string = wkt.write();

                searchItems.addLayer(layer);
                layer.on('click', function(e){
                    searchItems.removeLayer(layer);
                    // TODO clear search results
                });

                geoSearch(wkt_string, plan_id, function(data, textStatus, jqXHR) {
                    // TODO search results callback
                    console.log(textStatus);
                    console.log(data); // posts
                });

            }else{
                var popup_location = null;

                if (type === 'marker') {
                    layer.bindPopup(popup);
                    popup_location = e.layer._latlng;
                    var point = L.marker(e.layer._latlng);
                    wkt.fromObject(point);
                } else if (type === 'polygon'){
                    popup_location = e.layer._latlngs[0];
                    wkt.fromObject(L.polygon(e.layer._latlngs))
                }

                console.log(wkt.components);
                var wkt_string = wkt.write();
                console.log(wkt_string);

                var popup = L.popup()
                    .setLatLng(popup_location)
                    .setContent("<div>" +
                                             "<div style='font-size:.8em'> " +
                                             "<label>Komentarz</label><br>" +
                                             "<textarea id='popup_comment' rows='3'>" +
                                             "</textarea><br>" +
                                             "<input id='geometry' type='hidden' value='"+wkt_string+"'/>" +
                                             "<input id='feature_id' type='hidden' value='"+"'/>" +
                                             "</div> " +
                                             "<button onclick='addPopup(this);return false;' >Dodaj</button>" +
                                             "</div>");
                map.openPopup(popup);
                drawnItems.addLayer(layer);
            }

		});


        addGeometry(function(){
            //vectors.events.register('featureadded','',featureAddedFunction);
        });

    }


    function setVectorStyle(name,color){
        return new OpenLayers.StyleMap({
				        "default": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: .7,
				            strokeWidth: 1,
				            fillColor: color,
				            fillOpacity: .5,
				            cursor: "pointer"
				        }),
				        "temporary": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: 1,
				            strokeWidth: 2,
				            fillColor: color,
				            fillOpacity: .9,
				            cursor: "pointer",
				            label: ""+name// "${"+MapLayerList[x]['name_param']+"}"
				        }),
				        "select": new OpenLayers.Style({
				            strokeColor: color,
				            strokeOpacity: .9,
				            strokeWidth: 2,
				            fillColor: color,
				            fillOpacity: .9,
				            graphicZIndex: 2,
				            cursor: "pointer"
				        })
        });
    }

    function addGeometry(callback){
        $.getJSON( "/zr/api/geometries/?format=json", function( data ) {
            var count = data.length;
            $.each(data,function(key,value){
                parseWKT(value.geoelement,value.name);
                if(!--count){
                    callback();
                }
            })
        });
    }

    function parseWKT(value, name) {
        var wkt = new Wkt.Wkt();
        wkt.read(value);
        var components = wkt.components[0];

        if (Array.isArray(components)){
            var latlngs = new Array();
            for (var i in components){
                var xy = components[i];
                var latlng = L.latLng(xy.y, xy.x);
                latlngs.push(L.latLng(xy.y, xy.x));
            }
            var polygon = L.polygon(latlngs);
            polygon.addTo(map);
        } else{
            var xy = components;
            var latlng = L.latLng(xy.y, xy.x);
            var marker = L.marker(latlng, {});
            marker.addTo(map);
        }
    }

    function toggleControl(element) {
        var map = {'Dodaj punkt':'point','Dodaj poligon':'polygon'};
        var control = drawControls[map[element.value]];
        control.activate();
    }
    function stripObj(obj){
        window.stripObj = obj;
    }
    function displayWKT(feature) {
        var str = wkt.write(feature);
        return str;
    }
    function addPopup(data){
        // get data from popup and send it to server
        var temp = {}
        var temp_geometry = $(data).parent().find('#geometry').val();
        if (temp_geometry.indexOf('POLYGON')!=-1){
            temp['poly']=temp_geometry;
        } else if (temp_geometry.indexOf('POINT')!=-1){
            temp['point']=temp_geometry;
        } else {
            alert('Error: no poly or point data detected!!');
        }
        temp['name']='noname';

        var comment = $(data).parent().find('#popup_comment').val();
        if(comment){
            $.ajax({
                url : "/zr/api/geometries/",
                type: "POST",
                data : temp,
                headers: {'X-CSRFToken': $.cookie('csrftoken')},
                success: function(data, textStatus, jqXHR)
                {
                    addComentToGeoElement(data,comment);
                },
                error: function (jqXHR, textStatus, errorThrown)
                {
                    console.log('error: ' + textStatus);
                }
            });
            map.closePopup();
        } else {
            alert('comment needed!');
        }
    }

    function addComentToGeoElement(data, comment){
        var pushCommentIntoScope = $("#div_apiList").scope().pushCommentIntoScope;
        pushCommentIntoScope(data, comment);
        $("#div_apiList").scope().$apply();
    }
    function deletePopoup(data){
        // get data from popup and send it to server
        var feature_id = $(data).parent().find('#feature_id').val();
        vectors.eraseFeatures([vectors.getFeatureById(feature_id)]);
        map.popups[0].destroy();
    }

    function geoSearch(wkt, plan_id, success_callback){
        console.log('geosearching:');
        console.log(wkt);
        console.log(plan_id);
        if(wkt){
            $.ajax({
                url : '/zr/api/geosearch/'+plan_id+'/',
                type: 'POST',
                data : 'wkt='+wkt,
                //headers: {'X-CSRFToken': $.cookie('csrftoken')},
                success: success_callback,
                error: function (jqXHR, textStatus, errorThrown)
                {
                    console.log('error: ' + textStatus);
                }
            });
        } else {
            alert('Search are needed!');
        }
    }
</script>

<div id="map" class="smallmap"></div>
